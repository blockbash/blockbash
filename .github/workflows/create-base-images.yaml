# ##############################################################################
# PURPOSE: A generic factory for creating container images.
# - Local environment:
#   - Creates the runner image.

# - Hosted environment:
#   - Creates a cache image that CAN be consumed by create_challenge_environments.  As create_challenge_environments runs in a matrix configuration, this allows the image builders to speed up their build process.
#   - Running this step shouldn't slow down the local environment as the docker cache (generated by this step) can be reused in create_challenge_environments
# ##############################################################################

# yamllint disable-line rule:truthy
on:
  workflow_call:
    inputs:
      dockerfile_path:
        required: true
        type: string
      image_name_short:
        required: true
        type: string
      is_enabled:
        required: true
        type: string
      primary_json_string:
        required: true
        type: string
      target_arch:
        required: true
        type: string
    secrets:
      COSIGN_KEY_BASE64:
        required: true
      COSIGN_PASSWORD_BASE64:
        required: true
      _GITHUB_TOKEN:
        required: true

jobs:
  create_base_images:
    environment: ${{ github.ref_name }}
    runs-on: ubuntu-22.04
    steps:
      - if: ${{ false }}
        shell: bash
        id: "null"
        # language=sh
        run: |
          # Hacky way for GITHUB WORKFLOW plugin to recognize GITHUB_ENV
          # echo "build_scripts_workflow_steps_dir_path=null" >> $GITHUB_ENV
          # echo "docker_challenge_base_image_name_short=null" >> $GITHUB_ENV
      - if: inputs.is_enabled == 'true'
        name: Checkout (GitHub)
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - if: inputs.is_enabled == 'true'
        # See commentary in create-deployment.yaml as to why we are doing this if
        # statement on all job steps
        name: Job Init
        uses: ./.github/workflows/composite-actions/job-init
        with:
          cosign_key_base64: ${{ secrets.COSIGN_KEY_BASE64 }}
          cosign_password_base64: ${{ secrets.COSIGN_PASSWORD_BASE64 }}
          _github_token: ${{ secrets._GITHUB_TOKEN }}
          primary_json_string: ${{ inputs.primary_json_string }}
      - id: create_base_images
        if: inputs.is_enabled == 'true'
        name: Execute create-base-images.sh
        # language=sh
        run: |
          # RUNNER_ARCH: Is set via current Github runner
          bash "${build_scripts_workflow_steps_dir_path}/create-base-images.sh" \
            --branch_name=${branch_name} \
            --current_arch=${RUNNER_ARCH} \
            --dockerfile_path='${{ inputs.dockerfile_path }}' \
            --image_name_short='${{ inputs.image_name_short }}' \
            --is_scheduled_execution=${is_scheduled_execution} \
            --should_publish=${should_publish} \
            --should_publish_images=${should_publish_images} \
            --should_user_environment_die_on_error=${should_user_environment_die_on_error} \
            --target_arch='${{ inputs.target_arch }}' \
            --target_name='${{ inputs.image_name_short }}'

          # Hacky way for GITHUB WORKFLOW plugin to recognize GITHUB_OUTPUTS
          # echo "hashed_matrix_guid=null" >> $GITHUB_OUTPUT
          # echo "image_name_with_branch_arch_full=null" >> $GITHUB_OUTPUT
          # echo "image_name_with_branch_full=null" >> $GITHUB_OUTPUT
          # echo "image_name_with_sha_full=null" >> $GITHUB_OUTPUT
      # env.docker_challenge_base_image_name_short: We only publish a cache image for
      # this image.  The cache image is pushed to the registry within create-base-images.sh
      - if: inputs.is_enabled == 'true' && inputs.image_name_short != env.docker_challenge_base_image_name_short
        name: publish-images
        uses: ./.github/workflows/composite-actions/publish-images
        with:
          hashed_matrix_guid: ${{ steps.create_base_images.outputs.hashed_matrix_guid }}
          image_name_with_branch_arch_full: ${{ steps.create_base_images.outputs.image_name_with_branch_arch_full }}
          image_name_with_branch_full: ${{ steps.create_base_images.outputs.image_name_with_branch_full }}
          image_name_with_sha_full: ${{ steps.create_base_images.outputs.image_name_with_sha_full }}
      - id: cleanup_actions
        if: inputs.is_enabled == 'true' && always()
        name: Execute Cleanup Actions
        # language=sh
        run: |
          bash '${{ env.build_scripts_workflow_steps_dir_path }}/cleanup-job.sh' \
            --is_docker_build="false"
