#!/usr/bin/env bash

get_labs_github_org_name() {
  local _branch_name="${1}"

  local _github_org_name
  if is_production_build "${_branch_name}"; then
    _github_org_name="${github_labs_org_name_prod}"
  else
    _github_org_name="${github_labs_org_name_dev}"
  fi

  echo -n "${_github_org_name}"
}

get_build_lab_guid_bash() {
  # ##############################################################################
  : << COMMENT

  After create_lab_configuration_files() is called, we should only read configuration values from the artifact files (i.e., dont pull configurations from files that were used to generate the artifact files).  However, there are certain contexts in which we don't know which configuration file to leverage.  For cases where we only have the lab_environment_dir_path available, we can use this function to fetch the correct lab_guid_bash.  Once we have lab_guid_bash, we can fetch configurations from the artifact files that were generated by create_configurations.  See set_lab_metadata_value/get_lab_metadata_value

COMMENT
  # ##############################################################################

  local lab_environment_dir_path="${1}"

  # Fetch value from the "source of truth" for lab_guid_bash
  get_json_value "${key_build_args}.${key_lab_guid_bash}" "${lab_environment_dir_path}/${build_time_devcontainer_file_name}"
}

get_container_lab_guid_bash() {
  get_container_state_value "${key_lab_guid_bash}"
}

get_lab_metadata_value() {
  # Fetch value from lab metadata file that's declared in local environment
  # For fetching lab metadata from Github, see get_remote_devcontainer_metadata_value
  local key="${1}"
  local lab_guid_bash="${2}"
  get_json_value ".${key}" "$(get_lab_metadata_file_path "${lab_guid_bash}")"
}

set_container_state_value() {
  # ##############################################################################
  : << COMMENT

  PURPOSE:  Set container configuration values that i) are set from within the container (e.g., has_bootstrapped) ii) allow the correct lab metadata file to be located (e.g., lab_guid_bash).
    + From within the container, we dont want to mutate the lab metadata file as the blockbash repo can be bind mounted into the container.

COMMENT
  # ##############################################################################

  # Any container configuration values (that are resolved at run time)
  # need to be set via this method.  Add
  local key="${1}"
  local value="${2}"

  set_json_value "${key}" "${value}" "${container_state_file_path}"
}

get_container_state_value() {
  local key="${1}"

  get_json_value ".${key}" "${container_state_file_path}"
}

invoke_contract_compilation() {
  log_debug "Compiling Solidity contracts and generating contract types"
  pnpm run --filter @blockbash/lab-core contract:compile
}

invoke_lab() {
  local challenge_group_guid="${1}"
  local solution="${2}" # true/false

  local npm_script
  if [[ ${solution} == "${true}" ]]; then
    npm_script="challenges:verify_solution"
  elif [[ ${solution} == "${false}" ]]; then
    npm_script="challenges:verify"
  else
    die "Solution arg was not true/false"
  fi

  log_info "Executing challenge group guid: ${challenge_group_guid}.  Solution: ${solution}"

  # Use workaround to disable command echoing.  Once the issue (below) is
  # fixed, we can leverage the command (above)
  # https://github.com/pnpm/pnpm/issues/4802
  cd "${container_repo_dir_path}" && pnpm --filter @blockbash/lab-shell exec -- pnpm --silent "${npm_script}" "${challenge_group_guid}" && cd -
}

get_remote_devcontainer_metadata_value() {
  # Fetch value from lab metadata section that was fetched from lab repo (in Github)
  # Within Github, all configurations are placed within one file (.devcontainer.json).
  # In this case, certain lab metadata is found within the '.customizations.blockbash.' namespace
  local key="${1}"
  get_json_value ".customizations.blockbash.${key}" "${container_remote_config_file_path}"
}

get_lab_image_name_short() {
  local lab_guid_bash="${1}"
  local lab_release="${2}"
  echo "${lab_guid_bash}-${lab_release}"
}

init_outputs() {
  # If bb_current_lab_guid_bash is changed, we need to regenerate the configurations
  create_configurations "${BLOCKBASH_GLOBAL_BRANCH_NAME:-$(get_current_git_branch)}"
}

get_lab_core_cli_outputs_dir_path() {
  local input_file_name="${1}"
  local input_file_extention="${2}"
  local file_prefix="${3}"
  local output_dir_path="${4}"

  local no_prefix_input_file_name
  no_prefix_input_file_name=$(basename "${input_file_name}" "${input_file_extention}")

  local output_file_name="${file_prefix}${no_prefix_input_file_name}.txt"

  echo "${output_dir_path}/${output_file_name}"
}

execute_slither() {
  local analyzed_file_name="${1}"
  local file_prefix="${2}"
  local cwd="${3}"

  # cd into the contracts directory so output is consistent to what learner
  # would witness
  cd "${cwd}" || die "Couldn't cd into ${cwd}"

  local results_file_path
  results_file_path=$(get_lab_core_cli_outputs_dir_path "${analyzed_file_name}" ".sol" "${file_prefix}" "${container_lab_core_outputs_slither_dir_path}")

  persist_stdout "slither --solc-disable-warnings ${analyzed_file_name}" "${results_file_path}" "${true}"

  # Trim the solc output that doesn't provide any value
  sed "/^'solc/d" -i "${results_file_path}"
}

get_lab_vscode_url() {
  local lab_repo_name_full="${1}"

  local url_prefix="https://vscode.dev/redirect?url=vscode://ms-vscode-remote.remote-containers/cloneInVolume?url"
  local url_query_value
  if is_github_build; then
    url_query_value="${github_url}/${lab_repo_name_full}"
  else
    url_query_value="${git_user}@${github_primary_domain}:${lab_repo_name_full}.git"
  fi
  echo -n "${url_prefix}=${url_query_value}"
}

get_lab_codespaces_url() {
  local lab_repo_name_full="${1}"

  echo -n "${github_url}/codespaces/new/${lab_repo_name_full}?quickstart=1"
}

get_lab_metadata_file_path() {
  # Fetches the lab metadata for a SINGLE lab
  # For all configs, see: build_artifacts_labs_metadata_file_path
  local lab_guid_bash="${1}"

  local lab_specific_artifact_dir_path
  lab_specific_artifact_dir_path="$(get_lab_specific_artifact_dir_path "${lab_guid_bash}")"

  echo -n "${lab_specific_artifact_dir_path}/metadata.json"
}

get_lab_raw_repo_url() {
  local lab_repo_name_full="${1}"
  # We create a lab repo for every branch.  Thus, the branch is always main (see below)
  # Ex: https://raw.githubusercontent.com/blockbash-labs-dev/reentrancy-fundamentals-attack-develop/main/.devcontainer.json
  echo -n "${github_raw_content_url}/${lab_repo_name_full}/${production_branch}"
}

create_build_time_devcontainer_artifact_file() {
  local lab_environment_dir_path="${1}"
  local artifact_file_path="${2}"

  local build_time_devcontainer_base_file_path
  build_time_devcontainer_base_file_path="$(mktemp)"

  # build_build_time_devcontainer_base_template_file_path: Base devcontainer configuration that is ultimately merged into all lab-specific devcontainers.
  jq \
    "${jq_common_flags[@]}" \
    --null-input \
    --arg "container_lab_core_compilers_solcjs_symlink_file_path" "${container_lab_core_compilers_solcjs_symlink_file_path}" \
    --from-file "${build_build_time_devcontainer_base_template_file_path}" > "${build_time_devcontainer_base_file_path}"

  # build_time_devcontainer_override_file_path: lab specific devcontainers.  When merging logic is applied, the configurations in this file will take precedence over build_time_devcontainer_base_file_path values.
  local build_time_devcontainer_override_file_path="${lab_environment_dir_path}/${build_time_devcontainer_file_name}"

  merge_json_files "${build_time_devcontainer_base_file_path}" "${build_time_devcontainer_override_file_path}" "${artifact_file_path}"

  rm -rf "${build_time_devcontainer_base_file_path}"
}

create_lab_configuration_files() {
  # ##############################################################################
  : << COMMENT

  PURPOSE: Create configurations that power the lab environment.  The artifacts are listed below.
    + "build-time" devcontainer configurations: Files that power the devcontainer build process within create-lab-enviornments.sh
    + "run-time" devcontainer configurations: Files that are fetched from github and are leveraged to bootstrap the lab environment.
    + lab metadata file(s): lab configurations that are shared across the host workstation, CI, container-based lab environment.  These settings also can be referenced within typescript.

COMMENT
  # ##############################################################################

  local branch_name="${1}"

  mkdir -p "${build_artifacts_lab_specific_dir_path}"
  delete_nested_directories "${build_artifacts_lab_specific_dir_path}"

  local lab_environment_dir_path
  for lab_environment_dir_path in "${build_lab_environments_dir_path}"/*/; do

    local lab_guid_bash
    lab_guid_bash="$(get_build_lab_guid_bash "${lab_environment_dir_path}")"

    local devcontainer_build_time_artifact_file_path
    devcontainer_build_time_artifact_file_path="$(get_devcontainer_artifact_file_path "${lab_guid_bash}" "${build_time_prefix}")"

    create_build_time_devcontainer_artifact_file "${lab_environment_dir_path}" "${devcontainer_build_time_artifact_file_path}"

    create_lab_metadata_file "${branch_name}" "${devcontainer_build_time_artifact_file_path}"

    if is_github_build; then
      create_run_time_devcontainer_artifact_file "${lab_guid_bash}" "${false}"
    else
      create_run_time_devcontainer_artifact_file "${lab_guid_bash}" "${true}"
    fi

  done

  shopt -s globstar
  # Create a json array of json objects
  jq "${jq_common_flags[@]}" --slurp '.' "${build_artifacts_lab_specific_dir_path}"/**/metadata.json > "${build_artifacts_labs_metadata_file_path}"
  log_debug "Generated merged lab metadata file..."
  log_file_contents "${build_artifacts_labs_metadata_file_path}" "${debug_level}"
}

get_lab_repo_name_full() {
  # ##############################################################################
  : << COMMENT

  PURPOSE: Fetch the Github repo that corresponds to the lab.
  + We are ultimately generating a link that the learner clicks on: https://vscode.dev/redirect?url=vscode://ms-vscode-remote.remote-containers/cloneInVolume?url=https://github.com/blockbash-labs-dev/reentrancy-fundamentals-attack
  + To generate this link, we need to create a repo that ONLY contains the lab's .devcontainer.json.  If we house multiple devcontainer files within the repo, the link clicking experience doesn't work.
  + This link doesn't currently have the ability to pass in branch information as a query string parameter.  So we make a new repo for every branch in non-prod.

COMMENT
  # ##############################################################################

  local lab_guid_bash="${1}"
  local branch_name="${2}"

  local lab_guid_bash labs_github_org_name

  labs_github_org_name=$(get_labs_github_org_name "${branch_name}")

  local base_repo_name_full
  base_repo_name_full="${labs_github_org_name}/${lab_guid_bash}"

  if is_production_build "${branch_name}"; then
    echo -n "${base_repo_name_full}"
  else
    echo -n "${base_repo_name_full}-${branch_name}"
  fi
}

has_lab_bootstrapped_before() {
  local has_bootstrapped
  has_bootstrapped=$(get_container_state_value "${key_has_bootstrapped}")

  [[ ${has_bootstrapped} == "${true}" ]]
}

get_lab_specific_artifact_dir_path() {
  local lab_guid_bash="${1}"
  echo -n "${build_artifacts_lab_specific_dir_path}/${lab_guid_bash}"
}

create_lab_metadata_file() {
  local branch_name="${1}"
  local devcontainer_build_time_artifact_file_path="${2}"

  # START - Get appropriate context for metadata file
  local lab_open_relative_file_paths
  lab_open_relative_file_paths="$(get_json_value "${key_build_args}.${key_lab_open_relative_file_paths}" "${devcontainer_build_time_artifact_file_path}")"

  local lab_additional_symlinked_relative_file_paths
  lab_additional_symlinked_relative_file_paths="$(get_json_value "${key_build_args}.${key_lab_additional_symlinked_relative_file_paths}" "${devcontainer_build_time_artifact_file_path}")"

  local lab_guid_bash
  lab_guid_bash="$(get_json_value "${key_build_args}.${key_lab_guid_bash}" "${devcontainer_build_time_artifact_file_path}")"

  local default_challenge_prompt_group_guid_typescript
  default_challenge_prompt_group_guid_typescript="$(get_json_value "${key_build_args}.${key_default_challenge_prompt_group_guid_typescript}" "${devcontainer_build_time_artifact_file_path}")"

  local default_challenge_prompt_group_guid_typescript
  default_challenge_prompt_group_guid_typescript="$(get_json_value "${key_build_args}.${key_default_challenge_prompt_group_guid_typescript}" "${devcontainer_build_time_artifact_file_path}")"

  local default_challenge_solution_group_guid_typescript
  default_challenge_solution_group_guid_typescript="$(get_json_value "${key_build_args}.${key_default_challenge_solution_group_guid_typescript}" "${devcontainer_build_time_artifact_file_path}")"

  local lab_contracts_dir_name
  lab_contracts_dir_name="$(get_json_value "${key_build_args}.${key_lab_contracts_dir_name}" "${devcontainer_build_time_artifact_file_path}")"

  local lab_repo_name_full
  lab_repo_name_full="$(get_lab_repo_name_full "${lab_guid_bash}" "${branch_name}")"

  local lab_release
  lab_release="$(get_json_value "${key_build_args}.${key_lab_release}" "${devcontainer_build_time_artifact_file_path}")"

  local lab_codespace_url
  lab_codespace_url="$(get_lab_codespaces_url "${lab_repo_name_full}")"

  local image_name_short
  image_name_short="$(get_lab_image_name_short "${lab_guid_bash}" "${lab_release}")"

  local image_name_with_branch_full
  image_name_with_branch_full=$(get_image_name_with_branch_full "${branch_name}" "${image_name_short}")

  local container_name
  container_name="$(get_container_name "${docker_container_namespace_devcontainer}" "${image_name_short}" "${branch_name}")"

  local metadata_file_path
  metadata_file_path="$(get_lab_metadata_file_path "${lab_guid_bash}")"
  # END - Get appropriate context for metadata file

  # SETTERS
  set_json_value "${key_remote_devcontainer_file_url}" "$(get_lab_raw_repo_url "${lab_repo_name_full}")/${devcontainer_hidden_file_name}" "${metadata_file_path}"
  set_json_value "${key_lab_guid_bash}" "${lab_guid_bash}" "${metadata_file_path}"
  set_json_value "${key_image_name_short}" "${image_name_short}" "${metadata_file_path}"
  set_json_value "${key_image_name_with_branch_full}" "${image_name_with_branch_full}" "${metadata_file_path}"
  set_json_value "${key_default_challenge_prompt_group_guid_typescript}" "${default_challenge_prompt_group_guid_typescript}" "${metadata_file_path}"
  set_json_value "${key_default_challenge_solution_group_guid_typescript}" "${default_challenge_solution_group_guid_typescript}" "${metadata_file_path}"
  set_json_value "${key_lab_release}" "${lab_release}" "${metadata_file_path}"
  set_json_value "${key_lab_repo_name_full}" "${lab_repo_name_full}" "${metadata_file_path}"
  set_json_value "${key_codespace_url}" "${lab_codespace_url}" "${metadata_file_path}"
  set_json_value "${key_container_lab_contracts_dir_path}" "${container_lab_core_contracts_dir_path}/${lab_contracts_dir_name}" "${metadata_file_path}"
  set_json_value "${key_container_name}" "${container_name}" "${metadata_file_path}"
  set_json_value "${key_lab_open_relative_file_paths}" "${lab_open_relative_file_paths}" "${metadata_file_path}"
  set_json_value "${key_lab_additional_symlinked_relative_file_paths}" "${lab_additional_symlinked_relative_file_paths}" "${metadata_file_path}"
  set_json_value "${key_vscode_url}" "$(get_lab_vscode_url "${lab_repo_name_full}")" "${metadata_file_path}"

  log_debug "Generated individual lab metadata file..."
  log_file_contents "${metadata_file_path}" "${debug_level}"
}

get_devcontainer_artifact_file_path() {
  # The "artifact" is the FINAL version of the build-time or run-time devcontainer configuration
  local lab_guid_bash="${1}"
  local variant="${2}" # build-time/run-time

  local lab_specific_artifact_dir_path
  lab_specific_artifact_dir_path="$(get_lab_specific_artifact_dir_path "${lab_guid_bash}")"
  if [[ ${variant} == "${build_time_prefix}" ]]; then
    echo -n "${lab_specific_artifact_dir_path}/${build_time_devcontainer_file_name}"
  elif [[ ${variant} == "${run_time_prefix}" ]]; then
    echo -n "${lab_specific_artifact_dir_path}/${run_time_devcontainer_file_name}"
  else
    die "Variant (${variant}) is not correct"
  fi
}

create_vscode_tasks_file() {
  jq \
    --null-input \
    "${jq_common_flags[@]}" \
    --arg container_lab_shell_scripts_hooks_dir_path "${container_lab_shell_scripts_hooks_dir_path}" \
    --from-file "${lab_shell_config_vscode_dir_path}/tasks.template.json" > "${build_artifacts_lab_tasks_file_path}"
}

create_run_time_devcontainer_artifact_file() {
  local lab_guid_bash="${1}"
  local is_local="${2}"

  local run_time_devcontainer_artifact_file_path
  run_time_devcontainer_artifact_file_path="$(get_devcontainer_artifact_file_path "${lab_guid_bash}" "${run_time_prefix}")"

  local image_name_with_branch_full
  image_name_with_branch_full="$(get_lab_metadata_value "${key_image_name_with_branch_full}" "${lab_guid_bash}")"

  if [[ ${is_local} == "${true}" ]]; then
    local initialize_command="${lab_local_initialize_command}"
    local bind_source="${blockbash_root_dir_path}"
    local is_rm="${true}"
  else
    # Attempt to pull in latest docker image for a given release.  This will naturally pull in container package upgrades, etc.
    # For logic related to checking if a new release is available, see check-updates.sh.
    # We don't need to do this logic in the local environment as the latest image should
    # naturally be available.
    # https://github.com/microsoft/vscode-remote-release/issues/7104
    # https://github.com/alibaba/GraphScope/pull/2873/files
    local initialize_command="docker pull ${image_name_with_branch_full} || true"
    local bind_source="${null}"
    local is_rm="${false}"
  fi

  create_parent_directories_for_file "${run_time_devcontainer_artifact_file_path}"

  local container_name
  container_name="$(get_lab_metadata_value "${key_container_name}" "${lab_guid_bash}")"

  local lab_release
  lab_release="$(get_lab_metadata_value "${key_lab_release}" "${lab_guid_bash}")"

  local image_name_with_branch_full
  image_name_with_branch_full="$(get_lab_metadata_value "${key_image_name_with_branch_full}" "${lab_guid_bash}")"

  local docker_run_args_json
  docker_run_args_json=$(get_shared_lab_docker_run_flags "${container_name}" "${bind_source}" "json" "${is_rm}")

  rm -rf "${run_time_devcontainer_artifact_file_path}"
  jq \
    "${jq_common_flags[@]}" \
    --null-input \
    --argjson docker_run_args "${docker_run_args_json}" \
    --argjson "${key_lab_release}" "${lab_release}" \
    --arg "${key_image_name_with_branch_full}" "${image_name_with_branch_full}" \
    --arg "${key_initialize_command}" "${initialize_command}" \
    --from-file "${build_run_time_devcontainer_template_file_path}" > "${run_time_devcontainer_artifact_file_path}"

  if [[ ${bb_current_lab_guid_bash} == "${lab_guid_bash}" ]]; then
    log_info "Creating local devcontainer file for ${bb_current_lab_guid_bash}"
    create_parent_directories_for_file "${run_time_vscode_devcontainer_file_path}"
    # Create local variant for testing
    cp "${run_time_devcontainer_artifact_file_path}" "${run_time_vscode_devcontainer_file_path}"
  fi
  log_file_contents "${run_time_devcontainer_artifact_file_path}" "${debug_level}"
}
